# Parzen window

**Метод парзеновского окна** - классификатор,в котором вводится понятие функции ядра K(z), невозрастающую на ![](http://latex.codecogs.com/gif.latex?%5B0%2C%5Cinfty%29) и рассмотрим алгоритм
 ![](http://latex.codecogs.com/gif.latex?a%28u%3BX%5El%2Ch%2CK%29%20%3D%20%5Carg%5Cmax_%7By%5Cepsilon%20Y%7D%5Csum_%7Bi%3D1%7D%5El%20%5By_%7Bi%2Cu%7D%20%3D%20y%5DK%20%5Cleft%20%28%20%5Cfrac%7B%5Crho%28u%2Cx_%7Bi%2Cu%7D%29%20%7D%7Bh%7D%20%5Cright%20%29)   
Параметр _h_ называется _**шириной окна**_ и играет примерно ту же роль, что и число соседей **k**.
«Окно» — это сферическая окрестность объекта u радиуса _h_, при попадании в которую обучающего объекта ![](http://latex.codecogs.com/gif.latex?x_i) объект _u_ «притягивается» к классу ![](http://latex.codecogs.com/gif.latex?y_i).
Широко распространены такие ядра:

Для определения оптимального _h_ опять же используем **LOO**.

### Code implementation

Src: [тыц](../PW.R)

В данной работе использовалась новая функция для отрисовки ядер с LOO для каждого, ввиду громоздкости листинга здесь она не освещена.
По аналогии с предыдущими работами, использовалась немного видоизменённая функция LOO, которая вызывалась в цикле функции выше, и основная функция :
```R
DT.PW.PW = function(distances, classes, h) {
  distances = distances / h #реализация основной формулы алгоритма - деление расстояния на ширину ядра
  distances = DT.PW.currkernel(distances) #currKernel - своеобразная ссылка на функцию ядра, аргументом
  #которого является выражение выше
  classes = unique(classes)
   #делаем сет - уникальных элементов из classes и практически повторяем функцию из предыдущей работы
  w = sapply(classes, function(name, arr) sum(arr[names(arr) == name]), distances)
  names(w) = classes

  if (max(w) == 0) return("fail") #немного неактуально из - за использования гауссовского ядра
  
  return(names(which.max(w)))
}
```
### Summary

![](pics/PW.png)

Используется датасет iris по лепесткам для классификации.

На чартах LOO для каждого ядра можно заметить, что наилучшим результатом отработало гауссово ядро.Стоит заметить, что несмотря на небольшие отличия, оптимальное _h_ для первых четырёх ядер одинаковое. 

С прогонкой алгоритма для гауссовского ядра ушёл и недостаток — неспособность классифицировать ***все*** точки. В случае первых четырёх ядер _h_ = 0.35, что приводило к тому, что существовали точки (даже большее количество, если брать карту классификации), в радиусе которых не окажется известных точек. Тогда эти точки не классифицировались, отмечались другим цветом на карте.

----
[go to index](../README.md)  

[next - PF](PF.md)




